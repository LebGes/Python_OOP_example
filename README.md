# Python OOP
Задание на изучение ООП в языке Python

# Задача
- В качестве практической работы необходимо нарисовать блок-схемы работы алгоритма решения задач и загрузить в свой репозиторий в течение дня.
- В качестве домашней работы необходимо реализовать программы по ранее созданным алгоритмам решения задач на языке Python и загрузить в свой репозиторий до крайнего срока.

Даты сдачи оговариваются в канале группы.

# Теоретическая справка

**Объектно-ориентированное программирование (ООП)** – это парадигма программирования, которая основывается на концепции объектов. В Python, как и в других объектно-ориентированных языках, ООП позволяет создавать программы, используя объекты, каждый из которых представляет собой экземпляр класса.

## Основные принципы ООП:
* **Инкапсуляция** - заключается в сокрытии внутренней реализации объекта от внешнего мира. Это достигается за счет использования модификаторов доступа, чтобы ограничить доступ к полям и методам класса.
* **Наследование** - позволяет одному классу наследовать свойства и поведение другого класса. Это помогает повторно использовать код и строить иерархию классов.
* **Полиморфизм** -  означает возможность одного интерфейса работать с разными реализациями.
* **Абстракция** -  подразумевает выделение существенных характеристик объекта, скрывая при этом несущественные детали.

## SOLID
**SOLID** — это набор принципов объектно-ориентированного проектирования, предложенных Робертом Мартином (также известным как «Дядя Боб»). Эти принципы направлены на улучшение качества кода, повышение его устойчивости к изменениям и облегчение поддержки. Название SOLID является акронимом пяти основных принципов:

* **Single Responsibility Principle (Принцип единственной ответственности).** Этот принцип гласит, что у каждого класса должна быть одна единственная ответственность, и эта ответственность должна быть четко определена.
* **Open/Closed Principle (Принцип открытости/закрытости).** Согласно этому принципу, классы должны быть открыты для расширения, но закрыты для модификации. То есть вы можете добавлять новую функциональность, не меняя существующий код.
*  **Liskov Substitution Principle (Принцип подстановки Барбары Лисков).** Этот принцип утверждает, что объекты дочерних классов должны корректно заменять объекты своих родительских классов. Другими словами, если у вас есть базовый класс, то любой его подкласс должен вести себя так, чтобы клиентский код мог использовать его вместо базового класса без проблем.
*  **Interface Segregation Principle (Принцип разделения интерфейса).** Этот принцип гласит, что программные сущности не должны зависеть от методов, которые они не используют. Этот принцип рекомендует разделять большие интерфейсы на более мелкие и специализированные, чтобы классы использовали только те методы, которые им действительно нужны.
*  **Dependency Inversion Principle (Принцип инверсии зависимостей).** Этот принцип утверждает, что модули высокого уровня не должны зависеть от модулей низкого уровня. Оба типа модулей должны зависеть от абстракций, а абстракции не должны зависеть от деталей, а детали должны зависеть от абстракций. Этот принцип направлен на уменьшение связности между модулями и увеличение гибкости системы
